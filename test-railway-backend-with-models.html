<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Railway Backend Tester with Model & Voice Selection</title>
    <!-- Daily.co SDK -->
    <script crossorigin src="https://unpkg.com/@daily-co/daily-js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-align: center;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
        }
        
        .endpoint {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-family: 'Courier New', monospace;
            word-break: break-all;
        }
        
        .status {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .status.info { background: #e3f2fd; color: #1976d2; }
        .status.success { background: #e8f5e9; color: #388e3c; }
        .status.error { background: #ffebee; color: #c62828; }
        
        .badge {
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .badge.connected { background: #4caf50; color: white; }
        .badge.disconnected { background: #f44336; color: white; }
        .badge.pending { background: #ff9800; color: white; }
        
        .model-selection {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .model-selection h3 {
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .model-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .model-dropdown, .voice-dropdown {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
        }
        
        .model-dropdown label, .voice-dropdown label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }
        
        .model-dropdown select, .voice-dropdown select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
            color: #333;
            font-size: 14px;
            cursor: pointer;
        }
        
        .model-info, .voice-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 13px;
        }
        
        .model-type {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 5px;
        }
        
        .model-type.native-audio { background: #4caf50; color: white; }
        .model-type.half-cascade { background: #ff9800; color: white; }
        
        .voice-count {
            background: rgba(255, 255, 255, 0.2);
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            margin-left: 5px;
        }
        
        .button-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        
        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-primary { background: #667eea; color: white; }
        .btn-success { background: #48bb78; color: white; }
        .btn-danger { background: #f56565; color: white; }
        .btn-info { background: #4299e1; color: white; }
        
        .log {
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);
        }
        
        .log-entry {
            padding: 3px 0;
            border-bottom: 1px solid #333;
        }
        
        .log-entry.error { color: #ff6b6b; }
        .log-entry.success { color: #51cf66; }
        .log-entry.info { color: #74c0fc; }
        .log-entry.warning { color: #ffd43b; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÇ Railway Backend Tester with Model & Voice Selection</h1>
        <p class="subtitle">Test your Pipecat backend with different Gemini models and voices</p>
        
        <div class="endpoint">
            <strong>Backend URL:</strong> <span id="backendUrl">Loading...</span>
        </div>
        
        <div class="status info" id="status">
            <span id="statusText">Initializing...</span>
            <span class="badge disconnected" id="connectionBadge">DISCONNECTED</span>
        </div>
        
        <!-- Model & Voice Selection -->
        <div class="model-selection">
            <h3>ü§ñ Model & Voice Settings</h3>
            <div class="model-controls">
                <div class="model-dropdown">
                    <label for="modelSelect">Select Model:</label>
                    <select id="modelSelect">
                        <option value="">Loading models...</option>
                    </select>
                    <div class="model-info" id="modelInfo"></div>
                </div>
                
                <div class="voice-dropdown">
                    <label for="voiceSelect">Select Voice:</label>
                    <select id="voiceSelect">
                        <option value="">Select a model first</option>
                    </select>
                    <div class="voice-info" id="voiceInfo"></div>
                </div>
            </div>
        </div>
        
        <!-- Control Buttons -->
        <div class="button-group">
            <button id="connectBtn" class="btn-success" onclick="connectWithModel()">
                üéØ Connect with Selected Model
            </button>
            <button id="disconnectBtn" class="btn-danger" onclick="disconnectAudio()" disabled>
                üîå Disconnect Audio
            </button>
            <button id="clearBtn" class="btn-info" onclick="clearLogs()">
                üóëÔ∏è Clear Logs
            </button>
            <button id="refreshBtn" class="btn-primary" onclick="loadModels()">
                üîÑ Refresh Models
            </button>
        </div>
        
        <!-- Log Output -->
        <div class="log" id="logOutput">
            <div class="log-entry info">[System] Page loaded. Fetching models...</div>
        </div>
    </div>
    
    <script>
        // Configuration
        const BACKEND_URL = 'https://chat-vrd-backend-production.up.railway.app';
        let callObject = null;
        let roomUrl = null;
        let availableModels = {};
        let currentModel = null;
        let currentVoices = {};
        
        // Initialize
        window.addEventListener('DOMContentLoaded', async () => {
            document.getElementById('backendUrl').textContent = BACKEND_URL;
            await checkHealth();
            await loadModels();
        });
        
        // Model selection change handler
        document.getElementById('modelSelect').addEventListener('change', async (e) => {
            const modelId = e.target.value;
            if (modelId) {
                await loadVoicesForModel(modelId);
            } else {
                document.getElementById('voiceSelect').innerHTML = '<option value="">Select a model first</option>';
                document.getElementById('voiceInfo').textContent = '';
            }
        });
        
        // Voice selection change handler
        document.getElementById('voiceSelect').addEventListener('change', (e) => {
            const voiceId = e.target.value;
            if (voiceId && currentVoices[voiceId]) {
                const voice = currentVoices[voiceId];
                document.getElementById('voiceInfo').innerHTML = `
                    <strong>${voiceId}:</strong> ${voice.description}
                    <br>Languages: ${voice.languages.join(', ')}
                `;
            } else {
                document.getElementById('voiceInfo').textContent = '';
            }
        });
        
        // Load available models
        async function loadModels() {
            try {
                log('Fetching available models...', 'info');
                const response = await fetch(`${BACKEND_URL}/models`);
                const data = await response.json();
                
                availableModels = {};
                const modelSelect = document.getElementById('modelSelect');
                modelSelect.innerHTML = '<option value="">Select a model...</option>';
                
                data.models.forEach(model => {
                    availableModels[model.id] = model;
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = `${model.name} (${model.voice_count} voices)`;
                    modelSelect.appendChild(option);
                });
                
                log(`Loaded ${data.models.length} models`, 'success');
            } catch (error) {
                log(`Failed to load models: ${error.message}`, 'error');
            }
        }
        
        // Load voices for selected model
        async function loadVoicesForModel(modelId) {
            try {
                const model = availableModels[modelId];
                currentModel = model;
                
                // Update model info
                const typeClass = model.type === 'native-audio' ? 'native-audio' : 'half-cascade';
                document.getElementById('modelInfo').innerHTML = `
                    <strong>Type:</strong> <span class="model-type ${typeClass}">${model.type}</span>
                    <br>${model.description}
                    <br><strong>Features:</strong> ${model.features.join(', ')}
                    <br><strong>Available Voices:</strong> ${model.voice_count}
                `;
                
                // Load voices
                log(`Loading voices for ${model.name}...`, 'info');
                const response = await fetch(`${BACKEND_URL}/models/${modelId}/voices`);
                const data = await response.json();
                
                currentVoices = {};
                const voiceSelect = document.getElementById('voiceSelect');
                voiceSelect.innerHTML = '<option value="">Select a voice...</option>';
                
                data.voices.forEach(voice => {
                    currentVoices[voice.id] = voice;
                    const option = document.createElement('option');
                    option.value = voice.id;
                    option.textContent = `${voice.id} - ${voice.description}`;
                    voiceSelect.appendChild(option);
                });
                
                // Set default voice
                if (data.default_voice) {
                    voiceSelect.value = data.default_voice;
                    voiceSelect.dispatchEvent(new Event('change'));
                }
                
                log(`Loaded ${data.voices.length} voices for ${model.type} model`, 'success');
            } catch (error) {
                log(`Failed to load voices: ${error.message}`, 'error');
            }
        }
        
        // Check backend health
        async function checkHealth() {
            try {
                log('üîç Checking backend health...', 'info');
                const response = await fetch(`${BACKEND_URL}/health`);
                const data = await response.json();
                
                if (data.status === 'ok') {
                    updateStatus('Health check passed', 'success');
                    log(`‚úÖ Backend healthy - Service: ${data.service} v${data.version}`, 'success');
                    log(`ü§ñ Bot Available: ${data.bot_available}`, 'info');
                    log(`üìö Models Available: ${data.models_available}`, 'info');
                } else {
                    updateStatus('Health check failed', 'error');
                    log('‚ùå Backend unhealthy', 'error');
                }
            } catch (error) {
                updateStatus('Cannot reach backend', 'error');
                log(`‚ùå Health check failed: ${error.message}`, 'error');
            }
        }
        
        // Connect with selected model and voice
        async function connectWithModel() {
            const modelId = document.getElementById('modelSelect').value;
            const voiceId = document.getElementById('voiceSelect').value;
            
            if (!modelId) {
                log('‚ö†Ô∏è Please select a model', 'warning');
                return;
            }
            
            if (!voiceId) {
                log('‚ö†Ô∏è Please select a voice', 'warning');
                return;
            }
            
            try {
                log(`üîÑ Connecting with model: ${modelId}, voice: ${voiceId}...`, 'info');
                updateStatus('Connecting to backend...', 'info');
                
                const response = await fetch(`${BACKEND_URL}/connect`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model_id: modelId,
                        voice_id: voiceId,
                        language: 'en-US'
                    })
                });
                
                if (!response.ok) {
                    const error = await response.text();
                    throw new Error(error);
                }
                
                const data = await response.json();
                roomUrl = data.room_url;
                const token = data.token;
                
                log(`‚úÖ Room created: ${roomUrl}`, 'success');
                log(`ü§ñ Model: ${data.model.name} (${data.model.type})`, 'info');
                log(`üé§ Voice: ${data.voice.id} - ${data.voice.description}`, 'info');
                log(`ü§ñ Bot status: ${data.bot_status}`, 'info');
                
                // Join the Daily room
                await joinDailyRoom(roomUrl, token);
                
            } catch (error) {
                updateStatus('Connection failed', 'error');
                log(`‚ùå Connection error: ${error.message}`, 'error');
            }
        }
        
        // Join Daily room
        async function joinDailyRoom(url, token) {
            try {
                log('üìû Joining Daily room...', 'info');
                
                // Create Daily call object
                callObject = Daily.createCallObject({
                    audioSource: true,
                    videoSource: false
                });
                
                // Set up event listeners
                callObject.on('joined-meeting', () => {
                    log('‚úÖ Joined meeting successfully', 'success');
                    updateStatus('Connected to room', 'success');
                    updateConnectionBadge(true);
                    document.getElementById('connectBtn').disabled = true;
                    document.getElementById('disconnectBtn').disabled = false;
                });
                
                callObject.on('participant-joined', (event) => {
                    log(`üë§ Participant joined: ${event.participant.user_name || event.participant.session_id}`, 'info');
                });
                
                callObject.on('participant-left', (event) => {
                    log(`üëã Participant left: ${event.participant.user_name || event.participant.session_id}`, 'info');
                });
                
                callObject.on('error', (event) => {
                    log(`‚ùå Daily error: ${event.error}`, 'error');
                });
                
                // Join the room
                await callObject.join({ url, token });
                
            } catch (error) {
                log(`‚ùå Failed to join room: ${error.message}`, 'error');
                updateStatus('Failed to join room', 'error');
            }
        }
        
        // Disconnect audio
        async function disconnectAudio() {
            try {
                if (callObject) {
                    log('üîå Disconnecting from room...', 'info');
                    await callObject.leave();
                    await callObject.destroy();
                    callObject = null;
                    
                    log('‚úÖ Disconnected from room', 'success');
                    updateStatus('Disconnected', 'info');
                    updateConnectionBadge(false);
                    
                    document.getElementById('connectBtn').disabled = false;
                    document.getElementById('disconnectBtn').disabled = true;
                }
            } catch (error) {
                log(`‚ùå Disconnect error: ${error.message}`, 'error');
            }
        }
        
        // Update status
        function updateStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            const statusText = document.getElementById('statusText');
            
            statusDiv.className = `status ${type}`;
            statusText.textContent = message;
        }
        
        // Update connection badge
        function updateConnectionBadge(connected) {
            const badge = document.getElementById('connectionBadge');
            if (connected) {
                badge.className = 'badge connected';
                badge.textContent = 'CONNECTED';
            } else {
                badge.className = 'badge disconnected';
                badge.textContent = 'DISCONNECTED';
            }
        }
        
        // Logging
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logOutput = document.getElementById('logOutput');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${timestamp}] ${message}`;
            logOutput.appendChild(entry);
            logOutput.scrollTop = logOutput.scrollHeight;
            
            // Also log to console
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        // Clear logs
        function clearLogs() {
            document.getElementById('logOutput').innerHTML = '<div class="log-entry info">[System] Logs cleared</div>';
        }
    </script>
</body>
</html>